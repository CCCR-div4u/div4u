name: Kubernetes Security Scan with Checkov

on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'k8s/**'
  pull_request:
    branches:
      - main
      - develop
    paths:
      - 'k8s/**'
  workflow_dispatch:
  schedule:
    # ë§¤ì¼ ì˜¤ì „ 9ì‹œ (UTC)ì— ì‹¤í–‰
    - cron: '0 9 * * *'

env:
  CHECKOV_VERSION: '3.2.255'

jobs:
  k8s-security-scan:
    name: Kubernetes Security Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      security-events: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Checkov
        run: |
          pip install checkov==${{ env.CHECKOV_VERSION }}
          checkov --version

      - name: Create reports directory
        run: mkdir -p reports

      - name: Run Checkov scan on Kubernetes manifests
        run: |
          checkov \
            --directory k8s \
            --framework kubernetes \
            --output json \
            --output-file-path reports/checkov-results.json \
            --soft-fail
        continue-on-error: true

      - name: Generate SARIF report for GitHub Security
        run: |
          checkov \
            --directory k8s \
            --framework kubernetes \
            --output sarif \
            --output-file-path reports/checkov-results.sarif \
            --soft-fail
        continue-on-error: true

      - name: Upload SARIF results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        continue-on-error: true
        with:
          sarif_file: 'reports/checkov-results.sarif'
          category: 'checkov-k8s'

      - name: Set up Node.js for OpenAI analysis
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Create OpenAI analysis script
        run: |
          cat > analyze-checkov-results.js << 'EOF'
          const fs = require('fs');
          const https = require('https');

          async function analyzeCheckovResults() {
            try {
              // Checkov ê²°ê³¼ íŒŒì¼ ì½ê¸°
              const checkovResults = JSON.parse(fs.readFileSync('reports/checkov-results.json', 'utf8'));
              
              // ê²°ê³¼ ìš”ì•½ ìƒì„±
              const summary = {
                totalChecks: checkovResults.summary?.passed + checkovResults.summary?.failed + checkovResults.summary?.skipped || 0,
                passed: checkovResults.summary?.passed || 0,
                failed: checkovResults.summary?.failed || 0,
                skipped: checkovResults.summary?.skipped || 0,
                failedChecks: checkovResults.results?.failed_checks || []
              };

              // ì‹¤íŒ¨í•œ ê²€ì‚¬ë“¤ì„ ì‹¬ê°ë„ë³„ë¡œ ë¶„ë¥˜
              const criticalIssues = summary.failedChecks.filter(check => 
                check.severity === 'CRITICAL' || 
                check.check_id.includes('CKV_K8S_8') || // Liveness probe
                check.check_id.includes('CKV_K8S_9') || // Readiness probe
                check.check_id.includes('CKV_K8S_10') || // CPU limits
                check.check_id.includes('CKV_K8S_11') || // Memory limits
                check.check_id.includes('CKV_K8S_12') || // CPU requests
                check.check_id.includes('CKV_K8S_13') || // Memory requests
                check.check_id.includes('CKV_K8S_14') || // Image tag
                check.check_id.includes('CKV_K8S_15') || // Image pull policy
                check.check_id.includes('CKV_K8S_16') || // Container capabilities
                check.check_id.includes('CKV_K8S_17') || // Privileged containers
                check.check_id.includes('CKV_K8S_18') || // Hostnetwork
                check.check_id.includes('CKV_K8S_19') || // Hostpid
                check.check_id.includes('CKV_K8S_20') || // Hostipc
                check.check_id.includes('CKV_K8S_21') || // Default namespace
                check.check_id.includes('CKV_K8S_22') || // Non-root user
                check.check_id.includes('CKV_K8S_23') || // Read-only root filesystem
                check.check_id.includes('CKV_K8S_24') || // Allow privilege escalation
                check.check_id.includes('CKV_K8S_25') || // Run as non-root
                check.check_id.includes('CKV_K8S_26') || // Do not use hostPort
                check.check_id.includes('CKV_K8S_27') || // Do not use hostIPC
                check.check_id.includes('CKV_K8S_28') || // Do not use hostPID
                check.check_id.includes('CKV_K8S_29') || // Apply security context to pod
                check.check_id.includes('CKV_K8S_30')    // Apply security context to container
              );

              const highIssues = summary.failedChecks.filter(check => 
                check.severity === 'HIGH' && !criticalIssues.includes(check)
              );

              const mediumIssues = summary.failedChecks.filter(check => 
                check.severity === 'MEDIUM' && !criticalIssues.includes(check) && !highIssues.includes(check)
              );

              // OpenAI API í˜¸ì¶œì„ ìœ„í•œ í”„ë¡¬í”„íŠ¸ ìƒì„±
              const prompt = `
              Kubernetes ë³´ì•ˆ ê²€ì‚¬ ê²°ê³¼ë¥¼ ë¶„ì„í•´ì£¼ì„¸ìš”.

              ## ê²€ì‚¬ ìš”ì•½
              - ì´ ê²€ì‚¬ í•­ëª©: ${summary.totalChecks}
              - í†µê³¼: ${summary.passed}
              - ì‹¤íŒ¨: ${summary.failed}
              - ê±´ë„ˆëœ€: ${summary.skipped}

              ## ì‹¬ê°í•œ ë³´ì•ˆ ì´ìŠˆ (${criticalIssues.length}ê°œ)
              ${criticalIssues.map(issue => `
              - **${issue.check_id}**: ${issue.check_name}
                - íŒŒì¼: ${issue.file_path}
                - ì„¤ëª…: ${issue.description || 'N/A'}
                - ê°€ì´ë“œë¼ì¸: ${issue.guideline || 'N/A'}
              `).join('\n')}

              ## ë†’ì€ ìš°ì„ ìˆœìœ„ ì´ìŠˆ (${highIssues.length}ê°œ)
              ${highIssues.slice(0, 10).map(issue => `
              - **${issue.check_id}**: ${issue.check_name}
                - íŒŒì¼: ${issue.file_path}
              `).join('\n')}

              ## ì¤‘ê°„ ìš°ì„ ìˆœìœ„ ì´ìŠˆ (${mediumIssues.length}ê°œ)
              ${mediumIssues.slice(0, 5).map(issue => `
              - **${issue.check_id}**: ${issue.check_name}
                - íŒŒì¼: ${issue.file_path}
              `).join('\n')}

              ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ í•œêµ­ì–´ ë³´ê³ ì„œë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”:

              1. **ì „ì²´ ìš”ì•½**: ê²€ì‚¬ ê²°ê³¼ì˜ ì „ë°˜ì ì¸ ë³´ì•ˆ ìƒíƒœ í‰ê°€
              2. **ì£¼ìš” ë³´ì•ˆ ìœ„í—˜**: ì¦‰ì‹œ ìˆ˜ì •ì´ í•„ìš”í•œ Critical/High ì´ìŠˆë“¤
              3. **ê¶Œì¥ ì¡°ì¹˜ì‚¬í•­**: ê° ì´ìŠˆë³„ êµ¬ì²´ì ì¸ í•´ê²° ë°©ë²•
              4. **ìš°ì„ ìˆœìœ„**: ìˆ˜ì • ìš°ì„ ìˆœìœ„ì™€ ì¼ì • ì œì•ˆ
              5. **ëª¨ë²” ì‚¬ë¡€**: Kubernetes ë³´ì•ˆ ê°•í™”ë¥¼ ìœ„í•œ ì¼ë°˜ì ì¸ ê¶Œì¥ì‚¬í•­

              ë³´ê³ ì„œëŠ” ê°œë°œíŒ€ì´ ì´í•´í•˜ê¸° ì‰½ê³  ì‹¤í–‰ ê°€ëŠ¥í•œ ë‚´ìš©ìœ¼ë¡œ ì‘ì„±í•´ì£¼ì„¸ìš”.
              `;

              // OpenAI API í˜¸ì¶œ
              const openaiResponse = await callOpenAI(prompt);
              
              // ë³´ê³ ì„œ ìƒì„±
              const report = {
                timestamp: new Date().toISOString(),
                branch: process.env.GITHUB_REF_NAME,
                commit: process.env.GITHUB_SHA,
                summary: summary,
                analysis: openaiResponse,
                criticalCount: criticalIssues.length,
                highCount: highIssues.length,
                mediumCount: mediumIssues.length
              };

              // ë³´ê³ ì„œ íŒŒì¼ ì €ì¥
              fs.writeFileSync('reports/security-analysis-report.json', JSON.stringify(report, null, 2));
              
              // GitHub Issueìš© ë§ˆí¬ë‹¤ìš´ ìƒì„±
              const issueBody = generateIssueBody(report);
              fs.writeFileSync('reports/github-issue.md', issueBody);
              
              // Slack ë©”ì‹œì§€ ìƒì„±
              const slackMessage = generateSlackMessage(report);
              fs.writeFileSync('reports/slack-message.json', JSON.stringify(slackMessage, null, 2));

              console.log('Analysis completed successfully');
              
            } catch (error) {
              console.error('Error analyzing Checkov results:', error);
              process.exit(1);
            }
          }

          async function callOpenAI(prompt) {
            return new Promise((resolve, reject) => {
              const data = JSON.stringify({
                model: "gpt-4o-mini",
                messages: [
                  {
                    role: "system",
                    content: "ë‹¹ì‹ ì€ Kubernetes ë³´ì•ˆ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. Checkov ê²€ì‚¬ ê²°ê³¼ë¥¼ ë¶„ì„í•˜ì—¬ ì‹¤ìš©ì ì´ê³  êµ¬ì²´ì ì¸ ë³´ì•ˆ ê°œì„  ë°©ì•ˆì„ ì œì‹œí•´ì£¼ì„¸ìš”."
                  },
                  {
                    role: "user",
                    content: prompt
                  }
                ],
                max_tokens: 4000,
                temperature: 0.3
              });

              const options = {
                hostname: 'api.openai.com',
                port: 443,
                path: '/v1/chat/completions',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
                  'Content-Length': data.length
                }
              };

              const req = https.request(options, (res) => {
                let responseData = '';

                res.on('data', (chunk) => {
                  responseData += chunk;
                });

                res.on('end', () => {
                  try {
                    const response = JSON.parse(responseData);
                    if (response.choices && response.choices[0]) {
                      resolve(response.choices[0].message.content);
                    } else {
                      reject(new Error('Invalid OpenAI response'));
                    }
                  } catch (error) {
                    reject(error);
                  }
                });
              });

              req.on('error', (error) => {
                reject(error);
              });

              req.write(data);
              req.end();
            });
          }

          function generateIssueBody(report) {
            const severity = report.criticalCount > 0 ? 'ğŸ”´ Critical' : 
                           report.highCount > 0 ? 'ğŸŸ  High' : 
                           report.mediumCount > 0 ? 'ğŸŸ¡ Medium' : 'ğŸŸ¢ Low';

            return `# ğŸ›¡ï¸ Kubernetes ë³´ì•ˆ ê²€ì‚¬ ë³´ê³ ì„œ

          ## ğŸ“Š ê²€ì‚¬ ê²°ê³¼ ìš”ì•½
          - **ë¸Œëœì¹˜**: \`${report.branch}\`
          - **ì»¤ë°‹**: \`${report.commit.substring(0, 8)}\`
          - **ê²€ì‚¬ ì‹œê°„**: ${new Date(report.timestamp).toLocaleString('ko-KR')}
          - **ì „ì²´ ì‹¬ê°ë„**: ${severity}

          | êµ¬ë¶„ | ê°œìˆ˜ |
          |------|------|
          | âœ… í†µê³¼ | ${report.summary.passed} |
          | âŒ ì‹¤íŒ¨ | ${report.summary.failed} |
          | â­ï¸ ê±´ë„ˆëœ€ | ${report.summary.skipped} |
          | **ì´ê³„** | **${report.summary.totalChecks}** |

          ## ğŸš¨ ì‹¬ê°ë„ë³„ ì´ìŠˆ í˜„í™©
          - ğŸ”´ **Critical**: ${report.criticalCount}ê°œ
          - ğŸŸ  **High**: ${report.highCount}ê°œ  
          - ğŸŸ¡ **Medium**: ${report.mediumCount}ê°œ

          ## ğŸ¤– AI ë¶„ì„ ê²°ê³¼

          ${report.analysis}

          ## ğŸ“‹ ë‹¤ìŒ ë‹¨ê³„
          1. Critical ì´ìŠˆë¥¼ ìš°ì„ ì ìœ¼ë¡œ ìˆ˜ì •
          2. ë³´ì•ˆ ì •ì±… ì—…ë°ì´íŠ¸ ê²€í† 
          3. ì •ê¸°ì ì¸ ë³´ì•ˆ ê²€ì‚¬ ì¼ì • ìˆ˜ë¦½

          ---
          *ì´ ë³´ê³ ì„œëŠ” Checkovì™€ OpenAIë¥¼ í†µí•´ ìë™ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.*
          `;
          }

          function generateSlackMessage(report) {
            const severity = report.criticalCount > 0 ? 'danger' : 
                           report.highCount > 0 ? 'warning' : 'good';
            
            const severityEmoji = report.criticalCount > 0 ? 'ğŸ”´' : 
                                report.highCount > 0 ? 'ğŸŸ ' : 'ğŸŸ¢';

            return {
              text: `${severityEmoji} Kubernetes ë³´ì•ˆ ê²€ì‚¬ ì™„ë£Œ`,
              attachments: [
                {
                  color: severity,
                  title: "ğŸ›¡ï¸ div4u Kubernetes ë³´ì•ˆ ê²€ì‚¬ ê²°ê³¼",
                  fields: [
                    {
                      title: "ë¸Œëœì¹˜",
                      value: report.branch,
                      short: true
                    },
                    {
                      title: "ì»¤ë°‹",
                      value: report.commit.substring(0, 8),
                      short: true
                    },
                    {
                      title: "ì´ ê²€ì‚¬ í•­ëª©",
                      value: report.summary.totalChecks.toString(),
                      short: true
                    },
                    {
                      title: "ì‹¤íŒ¨í•œ ê²€ì‚¬",
                      value: report.summary.failed.toString(),
                      short: true
                    },
                    {
                      title: "Critical ì´ìŠˆ",
                      value: report.criticalCount.toString(),
                      short: true
                    },
                    {
                      title: "High ì´ìŠˆ", 
                      value: report.highCount.toString(),
                      short: true
                    }
                  ],
                  footer: "Checkov Security Scanner",
                  ts: Math.floor(Date.now() / 1000)
                }
              ]
            };
          }

          analyzeCheckovResults();
          EOF

      - name: Run OpenAI analysis
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          if [ -f "reports/checkov-results.json" ]; then
            node analyze-checkov-results.js
          else
            echo "Checkov results file not found"
            exit 1
          fi

      - name: Create GitHub Issue
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            try {
              // ê¸°ì¡´ ì´ìŠˆ ê²€ìƒ‰
              const existingIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['security', 'k8s-scan'],
                state: 'open'
              });

              // ì´ìŠˆ ë³¸ë¬¸ ì½ê¸°
              let issueBody = '';
              if (fs.existsSync('reports/github-issue.md')) {
                issueBody = fs.readFileSync('reports/github-issue.md', 'utf8');
              } else {
                issueBody = `# âš ï¸ Kubernetes ë³´ì•ˆ ê²€ì‚¬ ì‹¤íŒ¨
                
                Checkov ë³´ì•ˆ ê²€ì‚¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.
                
                - **ë¸Œëœì¹˜**: \`${{ github.ref_name }}\`
                - **ì»¤ë°‹**: \`${{ github.sha }}\`
                - **ì‹¤í–‰ ì‹œê°„**: ${new Date().toISOString()}
                
                ìì„¸í•œ ë‚´ìš©ì€ [ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ë¡œê·¸](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.`;
              }

              const title = `ğŸ›¡ï¸ K8s ë³´ì•ˆ ê²€ì‚¬ ê²°ê³¼ - ${context.payload.ref?.replace('refs/heads/', '') || 'Unknown Branch'} (${new Date().toISOString().split('T')[0]})`;

              if (existingIssues.data.length > 0) {
                // ê¸°ì¡´ ì´ìŠˆ ì—…ë°ì´íŠ¸
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existingIssues.data[0].number,
                  title: title,
                  body: issueBody
                });
                console.log(`Updated existing issue #${existingIssues.data[0].number}`);
              } else {
                // ìƒˆ ì´ìŠˆ ìƒì„±
                const issue = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: title,
                  body: issueBody,
                  labels: ['security', 'k8s-scan', 'automated']
                });
                console.log(`Created new issue #${issue.data.number}`);
              }
            } catch (error) {
              console.error('Error creating/updating GitHub issue:', error);
            }

      - name: Send Slack notification
        if: always()
        env:
          SLACK_WEBHOOK_URL_CHECKOV: ${{ secrets.SLACK_WEBHOOK_URL_CHECKOV }}
        run: |
          if [ -f "reports/slack-message.json" ] && [ -n "$SLACK_WEBHOOK_URL_CHECKOV" ]; then
            curl -X POST -H 'Content-type: application/json' \
              --data @reports/slack-message.json \
              "$SLACK_WEBHOOK_URL_CHECKOV"
            echo "Slack notification sent"
          else
            echo "Slack webhook URL not configured or message file not found"
          fi

      - name: Upload scan reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: k8s-security-reports-${{ github.sha }}
          path: reports/
          retention-days: 30

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            try {
              let reportSummary = '';
              if (fs.existsSync('reports/security-analysis-report.json')) {
                const report = JSON.parse(fs.readFileSync('reports/security-analysis-report.json', 'utf8'));
                
                const severity = report.criticalCount > 0 ? 'ğŸ”´ Critical' : 
                               report.highCount > 0 ? 'ğŸŸ  High' : 
                               report.mediumCount > 0 ? 'ğŸŸ¡ Medium' : 'ğŸŸ¢ Low';

                reportSummary = `## ğŸ›¡ï¸ Kubernetes ë³´ì•ˆ ê²€ì‚¬ ê²°ê³¼

                **ì „ì²´ ì‹¬ê°ë„**: ${severity}

                | êµ¬ë¶„ | ê°œìˆ˜ |
                |------|------|
                | âœ… í†µê³¼ | ${report.summary.passed} |
                | âŒ ì‹¤íŒ¨ | ${report.summary.failed} |
                | ğŸ”´ Critical | ${report.criticalCount} |
                | ğŸŸ  High | ${report.highCount} |
                | ğŸŸ¡ Medium | ${report.mediumCount} |

                ${report.criticalCount > 0 ? 'âš ï¸ **Critical ì´ìŠˆê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤. ë¨¸ì§€ ì „ì— ë°˜ë“œì‹œ ìˆ˜ì •í•´ì£¼ì„¸ìš”.**' : ''}
                
                ìì„¸í•œ ë¶„ì„ ê²°ê³¼ëŠ” [ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ë¡œê·¸](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`;
              } else {
                reportSummary = `## âš ï¸ Kubernetes ë³´ì•ˆ ê²€ì‚¬ ì‹¤íŒ¨
                
                ë³´ì•ˆ ê²€ì‚¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. [ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ë¡œê·¸](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.`;
              }

              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: reportSummary
              });
            } catch (error) {
              console.error('Error commenting on PR:', error);
            }
